<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domain & Range Practice</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use the Inter font family */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for correct/incorrect feedback */
        .correct-answer {
            border: 2px solid #22c55e; /* green-500 */
            background-color: #f0fdf4; /* green-50 */
        }
        .incorrect-answer {
            border: 2px solid #ef4444; /* red-500 */
            background-color: #fef2f2; /* red-50 */
        }
        .correct-text {
            color: #166534; /* green-800 */
            font-weight: 600;
        }
        .incorrect-text {
            color: #991b1b; /* red-800 */
            font-weight: 600;
        }
        /* Graph container */
        .graph-container {
            width: 100%;
            max-width: 350px;
            margin: 0 auto;
            position: relative;
            aspect-ratio: 1 / 1;
            border: 1px solid #ccc;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .graph-container svg {
            display: block;
            width: 100%;
            height: 100%;
        }
        .grid-line {
            stroke: #e5e7eb; /* Light gray */
            stroke-width: 1;
        }
        .axis-line {
            stroke: #4b5563; /* Darker gray */
            stroke-width: 2;
        }
        .axis-label {
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            fill: #4b5563;
        }
        
        /* Graph elements */
        .point-discrete {
            fill: #1f2937; /* gray-800 */
            r: 5;
        }
        .line-continuous {
            stroke: #1f2937; /* gray-800 */
            stroke-width: 3;
        }
        .endpoint-closed {
            fill: #1f2937;
            stroke: #1f2937;
            stroke-width: 2;
            r: 5;
        }
        .endpoint-open {
            fill: #ffffff;
            stroke: #1f2937;
            stroke-width: 2;
            r: 5;
        }

        /* Input styles */
        .profile-input {
            width: 100%;
            padding: 0.5rem;
            font-size: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            margin-top: 0.25rem;
        }
        .problem-fieldset {
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
            background-color: #fafafa;
        }
        .problem-legend {
            font-size: 1.25rem;
            font-weight: 700;
            padding: 0 0.5rem;
            color: #1f2937;
        }

        /* Symbol keyboard */
        .symbol-keyboard {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            margin-bottom: 1.5rem;
        }
        .symbol-btn {
            font-family: 'Menlo', 'Courier New', monospace;
            font-size: 1.25rem;
            font-weight: bold;
            width: 40px;
            height: 40px;
            border: 1px solid #d1d5db;
            background-color: #f9fafb;
            border-radius: 0.375rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .symbol-btn:hover {
            background-color: #e5e7eb;
        }
        .symbol-btn:active {
            background-color: #d1d5db;
            transform: translateY(1px);
        }
    </style>
    <!-- Import Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 min-h-screen p-4 md:p-8 flex items-center justify-center">

    <div class="max-w-4xl w-full">
        <!-- Header -->
        <header class="mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800 text-center">Domain & Range</h1>
            <p class="text-lg text-gray-600 text-center mt-2">Identify domain and range for discrete and continuous graphs</p>
            <!-- Game Stats -->
            <div id="game-stats" class="text-2xl font-bold text-center mt-4 text-gray-700 flex justify-center gap-6">
                <div id="lives-counter" class="text-red-500">Lives: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                <div id="score-counter" class="text-blue-600">Score: 0</div>
            </div>
        </header>

        <!-- Main Card -->
        <div class="bg-white p-6 md:p-8 rounded-lg shadow-xl">
            
            <!-- Symbol Keyboard -->
            <div class="symbol-keyboard">
                <button class="symbol-btn" data-symbol="{">{</button>
                <button class="symbol-btn" data-symbol="}">}</button>
                <button class="symbol-btn" data-symbol="[">[</button>
                <button class="symbol-btn" data-symbol="]">]</button>
                <button class="symbol-btn" data-symbol="(">(</button>
                <button class="symbol-btn" data-symbol=")">)</button>
                <button class="symbol-btn" data-symbol=",">,</button>
                <button class="symbol-btn" data-symbol="-">-</button>
            </div>

            <!-- Questions Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                
                <!-- Problem 1: Discrete -->
                <fieldset class="problem-fieldset">
                    <legend class="problem-legend">1. Discrete Function</legend>
                    
                    <!-- Graph -->
                    <div class="graph-container mb-4">
                        <svg id="svg-discrete" viewBox="0 0 350 350"></svg>
                    </div>

                    <!-- Inputs -->
                    <div class="space-y-3">
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Domain:</label>
                            <input type="text" id="disc-domain" class="profile-input" placeholder="e.g., {-2, 0, 5}">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Range:</label>
                            <input type="text" id="disc-range" class="profile-input" placeholder="e.g., {-1, 3, 4}">
                        </div>
                    </div>
                </fieldset>

                <!-- Problem 2: Continuous -->
                <fieldset class="problem-fieldset">
                    <legend class="problem-legend">2. Continuous Function</legend>
                    
                    <!-- Graph -->
                    <div class="graph-container mb-4">
                        <svg id="svg-continuous" viewBox="0 0 350 350"></svg>
                    </div>

                    <!-- Inputs -->
                    <div class="space-y-3">
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Domain:</label>
                            <input type="text" id="cont-domain" class="profile-input" placeholder="e.g., [-5, 3)">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Range:</label>
                            <input type="text" id="cont-range" class="profile-input" placeholder="e.g., [-2, 6)">
                        </div>
                    </div>
                </fieldset>

            </div>

            <!-- Feedback Area -->
            <div id="feedback-area" class="text-center h-6 mt-6 mb-4"></div>

            <!-- Buttons -->
            <div class="flex flex-col gap-3">
                <button id="check-btn" class="w-full bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-blue-700 transition-colors shadow-md">
                    Check Answer
                </button>
                <button id="next-btn" class="w-full bg-green-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-green-700 transition-colors shadow-md hidden">
                    Next Question
                </button>
                <button id="restart-btn" class="w-full bg-red-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-red-700 transition-colors shadow-md hidden">
                    Restart Game
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const livesCounter = document.getElementById('lives-counter');
        const scoreCounter = document.getElementById('score-counter');
        const feedbackArea = document.getElementById('feedback-area');
        const checkBtn = document.getElementById('check-btn');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        
        const inputs = {
            discDomain: document.getElementById('disc-domain'),
            discRange: document.getElementById('disc-range'),
            contDomain: document.getElementById('cont-domain'),
            contRange: document.getElementById('cont-range')
        };
        const allInputs = Object.values(inputs);
        
        const keyboard = document.querySelector('.symbol-keyboard');
        let lastFocusedInput = inputs.discDomain;

        // --- Game State ---
        let lives = 3;
        let score = 0;
        let isGameOver = false;
        let currentProblem = {};

        // --- Graphing Constants ---
        const SVG_SIZE = 350;
        const GRID_RANGE = 10;
        const NUM_GRIDS = GRID_RANGE * 2; // 20 grid boxes
        const GRID_SIZE = SVG_SIZE / NUM_GRIDS; // 17.5px
        const MID = SVG_SIZE / 2;

        // --- Helpers ---
        function getRandomInt(min, max, exclude = []) {
            let num;
            do {
                min = Math.ceil(min);
                max = Math.floor(max);
                num = Math.floor(Math.random() * (max - min + 1)) + min;
            } while (exclude.includes(num));
            return num;
        }

        function updateStatsDisplay() {
            livesCounter.innerHTML = `Lives: ${'‚ù§Ô∏è'.repeat(lives)}${'üñ§'.repeat(3 - lives)}`;
            scoreCounter.innerHTML = `Score: ${score}`;
        }

        function toPixel(val) {
            // Standard Cartesian to SVG (y inverted)
            // val 0 -> MID
            // val 10 -> SVG_SIZE
            // val -10 -> 0
            // x_px = MID + val * GRID_SIZE
            // y_px = MID - val * GRID_SIZE
            return MID + (val * GRID_SIZE);
        }
        function toPixelY(val) {
            return MID - (val * GRID_SIZE);
        }

        // --- SVG Drawing ---
        function drawGrid(svgId) {
            const svg = document.getElementById(svgId);
            svg.innerHTML = ''; // Clear

            // Grid lines
            for (let i = 0; i <= NUM_GRIDS; i++) {
                let pos = i * GRID_SIZE;
                // Horizontal
                let hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hLine.setAttribute('x1', 0); hLine.setAttribute('y1', pos);
                hLine.setAttribute('x2', SVG_SIZE); hLine.setAttribute('y2', pos);
                hLine.classList.add('grid-line');
                svg.appendChild(hLine);
                // Vertical
                let vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                vLine.setAttribute('x1', pos); vLine.setAttribute('y1', 0);
                vLine.setAttribute('x2', pos); vLine.setAttribute('y2', SVG_SIZE);
                vLine.classList.add('grid-line');
                svg.appendChild(vLine);
            }

            // Axes
            let xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', MID);
            xAxis.setAttribute('x2', SVG_SIZE); xAxis.setAttribute('y2', MID);
            xAxis.classList.add('axis-line');
            svg.appendChild(xAxis);

            let yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', MID); yAxis.setAttribute('y1', 0);
            yAxis.setAttribute('x2', MID); yAxis.setAttribute('y2', SVG_SIZE);
            yAxis.classList.add('axis-line');
            svg.appendChild(yAxis);

            // Labels (every 2 units)
            for (let i = -GRID_RANGE; i <= GRID_RANGE; i += 2) {
                if (i === 0) continue;
                // X labels
                let xTxt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xTxt.setAttribute('x', toPixel(i));
                xTxt.setAttribute('y', MID + 12);
                xTxt.setAttribute('text-anchor', 'middle');
                xTxt.textContent = i;
                xTxt.classList.add('axis-label');
                svg.appendChild(xTxt);

                // Y labels
                let yTxt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yTxt.setAttribute('x', MID - 4);
                yTxt.setAttribute('y', toPixelY(i) + 3);
                yTxt.setAttribute('text-anchor', 'end');
                yTxt.textContent = i;
                yTxt.classList.add('axis-label');
                svg.appendChild(yTxt);
            }
        }

        // --- Problem Generation ---

        function generateDiscrete() {
            const numPoints = getRandomInt(5, 6);
            const points = [];
            const usedX = new Set();

            for(let i=0; i<numPoints; i++) {
                let x = getRandomInt(-9, 9);
                while(usedX.has(x)) x = getRandomInt(-9, 9);
                usedX.add(x);
                let y = getRandomInt(-9, 9);
                points.push({x, y});
            }

            // Draw
            const svg = document.getElementById('svg-discrete');
            points.forEach(p => {
                let circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', toPixel(p.x));
                circle.setAttribute('cy', toPixelY(p.y));
                circle.classList.add('point-discrete');
                svg.appendChild(circle);
            });

            // Solutions
            const domainArr = Array.from(usedX).sort((a,b) => a - b);
            const rangeArr = [...new Set(points.map(p => p.y))].sort((a,b) => a - b);

            return {
                domain: domainArr,
                range: rangeArr
            };
        }

        function generateContinuous() {
            // Line segment with two endpoints
            let x1 = getRandomInt(-8, 5);
            let x2 = getRandomInt(x1 + 3, 9); // Ensure some width
            let y1 = getRandomInt(-8, 8);
            let y2 = getRandomInt(-8, 8);
            while(y1 === y2) y2 = getRandomInt(-8, 8); // Avoid horizontal for interest (though valid)

            const p1Open = Math.random() < 0.5;
            const p2Open = Math.random() < 0.5;

            const svg = document.getElementById('svg-continuous');
            
            // Draw Line
            let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', toPixel(x1));
            line.setAttribute('y1', toPixelY(y1));
            line.setAttribute('x2', toPixel(x2));
            line.setAttribute('y2', toPixelY(y2));
            line.classList.add('line-continuous');
            svg.appendChild(line);

            // Draw Endpoints
            function drawEnd(x, y, isOpen) {
                let circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', toPixel(x));
                circle.setAttribute('cy', toPixelY(y));
                circle.classList.add(isOpen ? 'endpoint-open' : 'endpoint-closed');
                svg.appendChild(circle);
            }
            drawEnd(x1, y1, p1Open);
            drawEnd(x2, y2, p2Open);

            // Solutions
            // Domain is straightforward as x1 < x2
            const dBracketL = p1Open ? '(' : '[';
            const dBracketR = p2Open ? ')' : ']';
            const domainStr = `${dBracketL}${x1},${x2}${dBracketR}`;

            // Range depends on min/max Y
            let minVal, maxVal, minOpen, maxOpen;
            if (y1 < y2) {
                minVal = y1; minOpen = p1Open;
                maxVal = y2; maxOpen = p2Open;
            } else {
                minVal = y2; minOpen = p2Open;
                maxVal = y1; maxOpen = p1Open;
            }
            const rBracketL = minOpen ? '(' : '[';
            const rBracketR = maxOpen ? ')' : ']';
            const rangeStr = `${rBracketL}${minVal},${maxVal}${rBracketR}`;

            return {
                domain: domainStr,
                range: rangeStr
            };
        }

        function startNewRound() {
            if(isGameOver) return;

            drawGrid('svg-discrete');
            drawGrid('svg-continuous');

            // Reset inputs
            allInputs.forEach(inp => {
                inp.value = '';
                inp.disabled = false;
                inp.classList.remove('correct-answer', 'incorrect-answer');
            });
            feedbackArea.textContent = '';
            checkBtn.classList.remove('hidden');
            nextBtn.classList.add('hidden');

            const discSol = generateDiscrete();
            const contSol = generateContinuous();

            currentProblem = {
                discrete: discSol,
                continuous: contSol
            };
        }

        // --- Answer Checking ---

        // Normalize discrete input: "{ -5, 2, 0 }" -> [-5, 0, 2]
        function parseDiscreteInput(str) {
            // Remove braces and spaces
            let clean = str.replace(/[{}]/g, '').replace(/\s/g, '');
            if(!clean) return [];
            // Split by comma, convert to int, sort unique
            let nums = clean.split(',').map(n => parseInt(n, 10)).filter(n => !isNaN(n));
            return [...new Set(nums)].sort((a,b) => a - b);
        }

        function checkDiscrete(inputEl, correctArr) {
            const userArr = parseDiscreteInput(inputEl.value);
            // Compare arrays
            if(JSON.stringify(userArr) === JSON.stringify(correctArr)) {
                inputEl.classList.add('correct-answer');
                inputEl.classList.remove('incorrect-answer');
                return true;
            }
            inputEl.classList.add('incorrect-answer');
            inputEl.classList.remove('correct-answer');
            return false;
        }

        function normalizeInterval(str) {
            return str.replace(/\s/g, '');
        }

        function checkContinuous(inputEl, correctStr) {
            const userStr = normalizeInterval(inputEl.value);
            if(userStr === normalizeInterval(correctStr)) {
                inputEl.classList.add('correct-answer');
                inputEl.classList.remove('incorrect-answer');
                return true;
            }
            inputEl.classList.add('incorrect-answer');
            inputEl.classList.remove('correct-answer');
            return false;
        }

        function checkAnswer() {
            const dDomainOk = checkDiscrete(inputs.discDomain, currentProblem.discrete.domain);
            const dRangeOk  = checkDiscrete(inputs.discRange, currentProblem.discrete.range);
            const cDomainOk = checkContinuous(inputs.contDomain, currentProblem.continuous.domain);
            const cRangeOk  = checkContinuous(inputs.contRange, currentProblem.continuous.range);

            const allCorrect = dDomainOk && dRangeOk && cDomainOk && cRangeOk;

            if(allCorrect) {
                score++;
                updateStatsDisplay();
                feedbackArea.innerHTML = `<p class="correct-text">Correct! Great job!</p>`;
                allInputs.forEach(i => i.disabled = true);
                checkBtn.classList.add('hidden');
                nextBtn.classList.remove('hidden');
            } else {
                lives--;
                updateStatsDisplay();
                if(lives <= 0) {
                    isGameOver = true;
                    feedbackArea.innerHTML = `<p class="incorrect-text text-xl font-bold">Game Over! Final Score: ${score}</p>`;
                    allInputs.forEach(i => i.disabled = true);
                    checkBtn.classList.add('hidden');
                    restartBtn.classList.remove('hidden');
                    
                    // Show answers
                    inputs.discDomain.value = `{${currentProblem.discrete.domain.join(', ')}}`;
                    inputs.discRange.value = `{${currentProblem.discrete.range.join(', ')}}`;
                    inputs.contDomain.value = currentProblem.continuous.domain;
                    inputs.contRange.value = currentProblem.continuous.range;
                } else {
                    feedbackArea.innerHTML = `<p class="incorrect-text">Check your brackets and values!</p>`;
                }
            }
        }

        function handleRestart() {
            lives = 3;
            score = 0;
            isGameOver = false;
            updateStatsDisplay();
            restartBtn.classList.add('hidden');
            startNewRound();
        }

        // Events
        checkBtn.addEventListener('click', checkAnswer);
        nextBtn.addEventListener('click', startNewRound);
        restartBtn.addEventListener('click', handleRestart);

        // Keyboard
        allInputs.forEach(input => {
            input.addEventListener('focus', () => lastFocusedInput = input);
        });
        keyboard.addEventListener('click', (e) => {
            if (e.target.classList.contains('symbol-btn')) {
                const symbol = e.target.dataset.symbol;
                if (lastFocusedInput) {
                    lastFocusedInput.value += symbol;
                    lastFocusedInput.focus();
                }
            }
        });

        // Init
        document.addEventListener('DOMContentLoaded', () => {
            updateStatsDisplay();
            startNewRound();
        });

    </script>
</body>
</html>