<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphing Linear Inequalities</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use the Inter font family */
        body {
            font-family: 'Inter', sans-serif;
        }
        .correct-text {
            color: #166534; /* green-800 */
            font-weight: 600;
        }
        .incorrect-text {
            color: #991b1b; /* red-800 */
            font-weight: 600;
        }
        /* Style for the graph */
        .graph-container {
            width: 100%;
            max-width: 480px; /* 480/16 = 30px per grid */
            margin: 0 auto;
            position: relative;
            aspect-ratio: 1 / 1; /* Keep it square */
            border: 1px solid #ccc;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            cursor: crosshair;
        }
        .graph-container svg {
            display: block;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Keep shade inside */
        }
        .grid-line {
            stroke: #e5e7eb; /* Light gray */
            stroke-width: 1;
        }
        .axis-line {
            stroke: #4b5563; /* Darker gray */
            stroke-width: 2;
        }
        .axis-label {
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            fill: #4b5563;
        }
        /* Student-drawn elements */
        .student-point {
            fill: #2563eb; /* blue-600 */
            stroke: #ffffff;
            stroke-width: 2;
        }
        .student-line {
            stroke: #2563eb; /* blue-600 */
            stroke-width: 3;
        }
        .student-line-dashed {
            stroke-dasharray: 5 5;
        }
        .shade-region {
            fill: #2563eb; /* blue-600 */
            opacity: 0.3;
        }
        .correct-line {
            stroke: #16a34a; /* green-600 */
            stroke-width: 4;
        }
        .correct-line-dashed {
            stroke-dasharray: 6 6;
        }
        .correct-shade {
            fill: #16a34a; /* green-600 */
            opacity: 0.3;
        }
        /* Style for line style buttons */
        .style-btn {
            background-color: #f3f4f6; /* gray-100 */
            border: 2px solid #d1d5db; /* gray-300 */
            color: #374151; /* gray-700 */
        }
        .style-btn-active {
            background-color: #dbeafe; /* blue-100 */
            border: 2px solid #3b82f6; /* blue-500 */
            color: #1e40af; /* blue-800 */
            font-weight: 600;
        }
    </style>
    <!-- Import Inter font from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 min-h-screen p-4 md:p-8 flex items-center justify-center">

    <div class="max-w-xl w-full">
        <!-- Header -->
        <header class="mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800 text-center">Graphing Linear Inequalities</h1>
            <p class="text-lg text-gray-600 text-center mt-2">Graph the inequality in 3 steps</p>
            <!-- Game Stats: Lives and Score -->
            <div id="game-stats" class="text-2xl font-bold text-center mt-4 text-gray-700 flex justify-center gap-6">
                <div id="lives-counter" class="text-red-500">Lives: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                <div id="score-counter" class="text-blue-600">Score: 0</div>
            </div>
        </header>

        <!-- Quiz Card -->
        <div class="bg-white p-6 md:p-8 rounded-lg shadow-xl">
            <!-- Equation to Graph -->
            <div class="text-center">
                <p class="text-lg text-gray-600">Graph the following inequality:</p>
                <p id="equation-display" class="text-4xl font-bold text-blue-600 my-3" style="font-family: 'Times New Roman', Times, serif;">y &lt; 2x + 1</p>
                <p id="instruction-text" class="text-lg text-gray-700 font-semibold h-6">1. Click the y-intercept.</p>
            </div>

            <!-- Graph Area -->
            <div class="my-4">
                <div class="graph-container" id="graph-container">
                    <svg id="svg-grid" viewBox="0 0 480 480"></svg>
                </div>
            </div>
            
            <!-- Feedback Area -->
            <div id="feedback-area" class="text-center h-12 mb-4">
                <!-- Feedback will be injected here -->
            </div>

            <!-- Button Area -->
            <!-- Step 3: Line Style Picker -->
            <div id="style-picker" class="grid grid-cols-2 gap-4 mb-4 hidden">
                <button id="solid-btn" class="style-btn w-full px-6 py-3 rounded-lg font-semibold text-lg transition-colors shadow-sm">Solid Line (‚Äî)</button>
                <button id="dashed-btn" class="style-btn w-full px-6 py-3 rounded-lg font-semibold text-lg transition-colors shadow-sm">Dashed Line (---)</button>
            </div>

            <!-- Main Control Buttons -->
            <div class="grid grid-cols-2 gap-4">
                <button id="reset-btn" class="w-full bg-gray-500 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-gray-600 transition-colors shadow-md hidden col-span-2">
                    Reset Graph
                </button>
                <button id="check-btn" class="w-full bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-blue-700 transition-colors shadow-md hidden col-span-2">
                    Check Answer
                </button>
                <button id="next-btn" class="w-full bg-green-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-green-700 transition-colors shadow-md hidden col-span-2">
                    Next Question
                </button>
                <button id="restart-btn" class="w-full bg-red-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-red-700 transition-colors shadow-md hidden col-span-2">
                    Restart Game
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const graphContainer = document.getElementById('graph-container');
        const svgGrid = document.getElementById('svg-grid');
        const equationDisplay = document.getElementById('equation-display');
        const instructionText = document.getElementById('instruction-text');
        const feedbackArea = document.getElementById('feedback-area');
        const checkBtn = document.getElementById('check-btn');
        const resetBtn = document.getElementById('reset-btn');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const stylePicker = document.getElementById('style-picker');
        const solidBtn = document.getElementById('solid-btn');
        const dashedBtn = document.getElementById('dashed-btn');
        const livesCounter = document.getElementById('lives-counter');
        const scoreCounter = document.getElementById('score-counter');

        // --- Game State ---
        let lives = 3;
        let score = 0;
        let isGameOver = false;
        let currentEquation = {};
        let clickedPoints = []; // Stores {x, y} cartesian coordinates
        let chosenLineStyle = null; // 'solid' or 'dashed'
        let clickedSideMatchesTestPoint = null; // Boolean: true if click is on same side as test point
        let nextEquationType = 'slopeIntercept'; // 'slopeIntercept' or 'standardForm'

        // --- Graphing Constants ---
        const SVG_SIZE = 480;
        const GRID_RANGE = 8; // -8 to 8
        const NUM_GRIDS = GRID_RANGE * 2; // 16
        const GRID_SIZE = SVG_SIZE / NUM_GRIDS; // 30px
        const MID = SVG_SIZE / 2;

        // --- Helper: Get Random Integer ---
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // --- Helper: Update Stats Display ---
        function updateStatsDisplay() {
            livesCounter.innerHTML = `Lives: ${'‚ù§Ô∏è'.repeat(lives)}${'üñ§'.repeat(3 - lives)}`;
            scoreCounter.innerHTML = `Score: ${score}`;
        }

        // --- Coordinate Conversion ---
        function toPixelCoords(cx, cy) {
            return {
                x: MID + (cx * GRID_SIZE),
                y: MID - (cy * GRID_SIZE) // SVG y-axis is inverted
            };
        }

        function toCartesianCoords(px, py) {
            return {
                x: Math.round((px - MID) / GRID_SIZE),
                y: Math.round((MID - py) / GRID_SIZE) // SVG y-axis is inverted
            };
        }

        // --- SVG Drawing ---
        function createSvgGrid() {
            svgGrid.innerHTML = ''; // Clear previous grid

            // Draw grid lines
            for (let i = 0; i <= NUM_GRIDS; i++) {
                let pos = i * GRID_SIZE;
                // Horizontal
                let hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hLine.setAttribute('x1', 0); hLine.setAttribute('y1', pos);
                hLine.setAttribute('x2', SVG_SIZE); hLine.setAttribute('y2', pos);
                hLine.classList.add('grid-line');
                svgGrid.appendChild(hLine);
                // Vertical
                let vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                vLine.setAttribute('x1', pos); vLine.setAttribute('y1', 0);
                vLine.setAttribute('x2', pos); vLine.setAttribute('y2', SVG_SIZE);
                vLine.classList.add('grid-line');
                svgGrid.appendChild(vLine);
            }

            // Draw axes
            let xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', MID);
            xAxis.setAttribute('x2', SVG_SIZE); xAxis.setAttribute('y2', MID);
            xAxis.classList.add('axis-line');
            svgGrid.appendChild(xAxis);

            let yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', MID); yAxis.setAttribute('y1', 0);
            yAxis.setAttribute('x2', MID); yAxis.setAttribute('y2', SVG_SIZE);
            yAxis.classList.add('axis-line');
            svgGrid.appendChild(yAxis);

            // Add axis labels
            function addLabel(x, y, text, align = 'middle', baseline = 'central') {
                let label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', y);
                label.setAttribute('text-anchor', align);
                label.setAttribute('dominant-baseline', baseline);
                label.textContent = text;
                label.classList.add('axis-label');
                svgGrid.appendChild(label);
            }

            for(let i = 1; i <= GRID_RANGE; i++) {
                if (i % 2 === 0) { // Label every 2 units
                    addLabel(MID + (i * GRID_SIZE), MID + 12, i); // +x
                    addLabel(MID - (i * GRID_SIZE), MID + 12, -i); // -x
                    addLabel(MID - 12, MID - (i * GRID_SIZE), i, 'end'); // +y
                    addLabel(MID - 12, MID + (i * GRID_SIZE), -i, 'end'); // -y
                }
            }
        }

        function drawPoint(cx, cy, id) {
            const p = toPixelCoords(cx, cy);
            let circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('id', id);
            circle.setAttribute('cx', p.x);
            circle.setAttribute('cy', p.y);
            circle.setAttribute('r', 5);
            circle.classList.add('student-point');
            svgGrid.appendChild(circle);
        }

        function drawFullLine(m, b, id, lineClass) {
            const x1 = -GRID_RANGE;
            const y1 = m * x1 + b;
            const x2 = GRID_RANGE;
            const y2 = m * x2 + b;
            const px1 = toPixelCoords(x1, y1);
            const px2 = toPixelCoords(x2, y2);
            
            let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('id', id);
            line.setAttribute('x1', px1.x);
            line.setAttribute('y1', px1.y);
            line.setAttribute('x2', px2.x);
            line.setAttribute('y2', px2.y);
            
            const classes = lineClass.split(' '); 
            line.classList.add(...classes); 
            
            svgGrid.appendChild(line);
        }
        
        // This function draws the shaded region.
        function drawShadeRegion(m, b, sideMatchesTest, id, shadeClass) {
            // sideMatchesTest: boolean. Does the side we want to shade contain the testPoint?
            const { A, B, C, testPoint } = currentEquation;
            
            let shadeAbove = false;
            
            // We need to determine if "Above" corresponds to "MatchesTest" or "!MatchesTest"
            // Use a Probe point clearly above the line: (0, b + 1)
            const probePoint = { x: 0, y: b + 1 };
            const probeVal = A * probePoint.x + B * probePoint.y;
            const testVal = A * testPoint.x + B * testPoint.y;
            
            // Is Probe on the same side as TestPoint?
            // If (Probe - C) and (Test - C) have same sign, result is positive.
            const isProbeSameAsTest = (probeVal - C) * (testVal - C) >= 0;
            
            // Logic:
            // If we want to shade the side matching TestPoint (sideMatchesTest == true):
            //    If Probe is also matching TestPoint -> Shade Above (where probe is).
            //    If Probe is NOT matching TestPoint -> Shade Below.
            // If we want to shade the side OPPOSITE TestPoint (sideMatchesTest == false):
            //    If Probe is matching TestPoint -> Shade Below (Away from probe).
            //    If Probe is NOT matching TestPoint -> Shade Above (Where probe is).
            
            if (sideMatchesTest) {
                shadeAbove = isProbeSameAsTest;
            } else {
                shadeAbove = !isProbeSameAsTest;
            }

            // Get the 4 corner points of the polygon
            const p1 = toPixelCoords(-GRID_RANGE, m * -GRID_RANGE + b); // Line Left
            const p2 = toPixelCoords(GRID_RANGE, m * GRID_RANGE + b); // Line Right
            let c1, c2;

            if (shadeAbove) {
                c1 = toPixelCoords(-GRID_RANGE, GRID_RANGE); // Top-Left Corner
                c2 = toPixelCoords(GRID_RANGE, GRID_RANGE); // Top-Right Corner
            } else {
                c1 = toPixelCoords(-GRID_RANGE, -GRID_RANGE); // Bottom-Left Corner
                c2 = toPixelCoords(GRID_RANGE, -GRID_RANGE); // Bottom-Right Corner
            }
            
            let polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('id', id);
            polygon.setAttribute('points', `${p1.x},${p1.y} ${p2.x},${p2.y} ${c2.x},${c2.y} ${c1.x},${c1.y}`);
            polygon.classList.add(shadeClass);
            svgGrid.appendChild(polygon);
        }

        function clearStudentDrawings() {
            const p1 = document.getElementById('point-1');
            const p2 = document.getElementById('point-2');
            const line = document.getElementById('student-line');
            const shade = document.getElementById('student-shade');
            const answerLine = document.getElementById('answer-line');
            const answerShade = document.getElementById('answer-shade');

            if (p1) p1.remove();
            if (p2) p2.remove();
            if (line) line.remove();
            if (shade) shade.remove();
            if (answerLine) answerLine.remove();
            if (answerShade) answerShade.remove();
        }

        // --- Problem Generation ---
        function generateProblem() {
            if (isGameOver) return;

            let m, b;
            do {
                m = getRandomInt(-3, 3);
            } while (m === 0); // No horizontal/vertical lines
            
            b = getRandomInt(-5, 5);
            
            const inequalityTypes = ['<', '>', '‚â§', '‚â•'];
            const inequalitySymbol = inequalityTypes[getRandomInt(0, 3)];
            const isSolid = inequalitySymbol === '‚â§' || inequalitySymbol === '‚â•';

            let A, B, C;
            
            if (nextEquationType === 'slopeIntercept') {
                // y [op] mx + b  =>  mx - y [op] -b
                A = m;
                B = -1;
                C = -b;
                // Adjust operator for B=-1 (when converting from slope intercept form)
                let opForCheck;
                if (inequalitySymbol === '>') opForCheck = '<';
                if (inequalitySymbol === '<') opForCheck = '>';
                if (inequalitySymbol === '‚â•') opForCheck = '‚â§';
                if (inequalitySymbol === '‚â§') opForCheck = '‚â•';
                
                let mStr = (m === 1) ? "x" : (m === -1) ? "-x" : `${m}x`;
                let bStr = (b > 0) ? `+ ${b}` : (b < 0) ? `- ${Math.abs(b)}` : "";
                equationDisplay.innerHTML = `y ${inequalitySymbol.replace('<=', '&le;').replace('>=', '&ge;')} ${mStr} ${bStr}`;
                
                currentEquation = { m, b, A, B, C, isSolid, inequalitySymbol: opForCheck };
                nextEquationType = 'standardForm';
            } else {
                // Generate Ax + By [op] C form
                if (m > 0) { // e.g., y = 2x + 3  =>  -2x + y = 3 => 2x - y = -3
                    A = m; B = -1; C = -b;
                } else { // e.g., y = -2x + 3 =>  2x + y = 3
                    A = -m; B = 1; C = b;
                }
                
                let opForCheck = inequalitySymbol;

                let A_str = (A === 1) ? "x" : `${A}x`;
                let B_str = (B === 1) ? "+ y" : (B === -1) ? "- y" : (B > 0) ? `+ ${B}y` : `- ${Math.abs(B)}y`;
                
                equationDisplay.innerHTML = `${A_str} ${B_str} ${inequalitySymbol.replace('<=', '&le;').replace('>=', '&ge;')} ${C}`;
                currentEquation = { m, b, A, B, C, isSolid, inequalitySymbol: opForCheck };
                nextEquationType = 'slopeIntercept';
            }

            // Final step: determine solution region.
            // BUG FIX: If line passes through origin (C=0), we cannot use (0,0) as test point.
            // We use (1,0) as fallback. Since m != 0, line is never y=0, so (1,0) is safe.
            let testPoint = { x: 0, y: 0 };
            if (currentEquation.C === 0) {
                testPoint = { x: 1, y: 0 };
            }
            
            const testVal = currentEquation.A * testPoint.x + currentEquation.B * testPoint.y;
            const C_val = currentEquation.C;
            const op = currentEquation.inequalitySymbol;

            if (op === '<') currentEquation.isTestPointSideCorrect = (testVal < C_val);
            if (op === '>') currentEquation.isTestPointSideCorrect = (testVal > C_val);
            if (op === '‚â§') currentEquation.isTestPointSideCorrect = (testVal <= C_val);
            if (op === '‚â•') currentEquation.isTestPointSideCorrect = (testVal >= C_val);
            
            currentEquation.testPoint = testPoint;

            resetState();
        }

        // --- Game Logic ---
        function handleGraphClick(event) {
            const rect = svgGrid.getBoundingClientRect();
            const px = event.clientX - rect.left;
            const py = event.clientY - rect.top;
            const p = toCartesianCoords(px, py);
            
            if (clickedPoints.length === 0) {
                // First click (y-intercept)
                clickedPoints.push(p);
                drawPoint(p.x, p.y, 'point-1');
                instructionText.textContent = '2. Click a second point for the boundary line.';
                resetBtn.classList.remove('hidden');
            } else if (clickedPoints.length === 1) {
                // Second click (slope point)
                if (p.x === clickedPoints[0].x && p.y === clickedPoints[0].y) return; // Ignore same point
                
                clickedPoints.push(p);
                drawPoint(p.x, p.y, 'point-2');
                instructionText.textContent = "3. Choose the line style.";
                stylePicker.classList.remove('hidden');
                graphContainer.style.pointerEvents = 'none'; // Disable graph clicks
            } else if (clickedPoints.length === 2 && chosenLineStyle) {
                // Third click (shading)
                const { A, B, C, testPoint } = currentEquation;
                
                // Check which side was clicked relative to the test point
                const clickVal = A * p.x + B * p.y;
                const testVal = A * testPoint.x + B * testPoint.y;
                
                // Check if click is on same side as test point
                // Note: If C=0, testVal is not 0 (because we shifted testPoint to 1,0), so this calculation is safe.
                const isClickOnSameSideAsTest = (clickVal - C) * (testVal - C) >= 0;
                clickedSideMatchesTestPoint = isClickOnSameSideAsTest;
                
                // Draw the shade
                const { m, b } = getLineFromPoints(clickedPoints[0], clickedPoints[1]);
                drawShadeRegion(m, b, clickedSideMatchesTestPoint, 'student-shade', 'shade-region');

                instructionText.textContent = "Check your work!";
                checkBtn.classList.remove('hidden');
                graphContainer.style.pointerEvents = 'none'; // Disable clicks
            }
        }

        function handleStyleClick(style) {
            chosenLineStyle = style;
            solidBtn.classList.toggle('style-btn-active', style === 'solid');
            dashedBtn.classList.toggle('style-btn-active', style === 'dashed');

            // Draw the student's line
            const existingLine = document.getElementById('student-line');
            if (existingLine) existingLine.remove();
            
            const { m, b } = getLineFromPoints(clickedPoints[0], clickedPoints[1]);
            let lineClass = 'student-line';
            if (style === 'dashed') lineClass += ' student-line-dashed';
            drawFullLine(m, b, 'student-line', lineClass);

            instructionText.textContent = "4. Click the correct region to shade.";
            graphContainer.style.pointerEvents = 'auto'; // Re-enable for shading
            stylePicker.classList.add('hidden');
        }

        function getLineFromPoints(p1, p2) {
            if (p1.x === p2.x) return { m: Infinity, b: undefined }; // Vertical
            const m = (p2.y - p1.y) / (p2.x - p1.x);
            const b = p1.y - m * p1.x;
            return { m, b };
        }

        function resetState() {
            clickedPoints = [];
            chosenLineStyle = null;
            clickedSideMatchesTestPoint = null;
            clearStudentDrawings();
            
            graphContainer.style.pointerEvents = 'auto'; // Re-enable clicks
            instructionText.textContent = '1. Click the y-intercept.';
            feedbackArea.innerHTML = '';
            
            checkBtn.classList.add('hidden');
            resetBtn.classList.add('hidden');
            nextBtn.classList.add('hidden');
            stylePicker.classList.add('hidden');
            solidBtn.classList.remove('style-btn-active');
            dashedBtn.classList.remove('style-btn-active');
        }

        function checkAnswer() {
            const p1 = clickedPoints[0];
            const p2 = clickedPoints[1];
            const { m, b, isSolid, isTestPointSideCorrect } = currentEquation;

            // Check 1: Is the y-intercept correct?
            const isInterceptCorrect = (p1.x === 0 && p1.y === b);
            
            // Check 2: Is the second point on the line?
            // Use a small tolerance for floating point
            const isSlopePointCorrect = Math.abs(p2.y - (m * p2.x + b)) < 0.001;
            
            // Check 3: Is the line style correct?
            const isStyleCorrect = (chosenLineStyle === (isSolid ? 'solid' : 'dashed'));

            // Check 4: Is the shading correct?
            // The student is correct if their click (relative to test point) matches the correct logic (relative to test point)
            const isShadeCorrect = (clickedSideMatchesTestPoint === isTestPointSideCorrect);

            checkBtn.classList.add('hidden');
            resetBtn.classList.add('hidden');

            if (isInterceptCorrect && isSlopePointCorrect && isStyleCorrect && isShadeCorrect) {
                // ALL CORRECT
                score++;
                updateStatsDisplay();
                feedbackArea.innerHTML = `<p class="correct-text">Correct! Great job!</p>`;
                
                // Draw correct answer
                clearStudentDrawings();
                let correctLineClass = isSolid ? 'correct-line' : 'correct-line correct-line-dashed';
                drawFullLine(m, b, 'answer-line', correctLineClass);
                
                drawShadeRegion(m, b, isTestPointSideCorrect, 'answer-shade', 'correct-shade');
                
                nextBtn.classList.remove('hidden');
            } else {
                // INCORRECT
                lives--;
                updateStatsDisplay();
                let errorMsgs = [];
                if (!isInterceptCorrect) errorMsgs.push("Your y-intercept is not in the correct spot.");
                else if (!isSlopePointCorrect) errorMsgs.push("Your y-intercept is right, but your second point is off the line.");
                
                if (!isStyleCorrect) errorMsgs.push(`The line should be <strong>${isSolid ? 'solid' : 'dashed'}</strong>.`);
                if (!isShadeCorrect) errorMsgs.push("You shaded the wrong region.");
                
                if (lives <= 0) {
                    // GAME OVER
                    isGameOver = true;
                    feedbackArea.innerHTML = `<p class="incorrect-text text-xl font-bold">Game Over! Final Score: ${score}</p>`;
                    // Show the correct answer
                    clearStudentDrawings();
                    
                    let correctLineClass = isSolid ? 'correct-line' : 'correct-line correct-line-dashed'; 
                    drawFullLine(m, b, 'answer-line', correctLineClass);
                    
                    drawShadeRegion(m, b, isTestPointSideCorrect, 'answer-shade', 'correct-shade');
                    restartBtn.classList.remove('hidden');
                } else {
                    // Try again
                    feedbackArea.innerHTML = `<p class="incorrect-text">${errorMsgs.join(' ')} Try again!</p>`;
                    resetBtn.classList.remove('hidden');
                    resetBtn.classList.add('col-span-2'); // Make reset button full width
                }
            }
        }

        function handleRestart() {
            lives = 3;
            score = 0;
            isGameOver = false;
            updateStatsDisplay();
            restartBtn.classList.add('hidden');
            generateProblem();
        }

        // --- Event Listeners ---
        svgGrid.addEventListener('click', handleGraphClick);
        solidBtn.addEventListener('click', () => handleStyleClick('solid'));
        dashedBtn.addEventListener('click', () => handleStyleClick('dashed'));
        checkBtn.addEventListener('click', checkAnswer);
        resetBtn.addEventListener('click', () => {
             resetState();
             instructionText.textContent = '1. Click the y-intercept.';
        });
        nextBtn.addEventListener('click', generateProblem);
        restartBtn.addEventListener('click', handleRestart);

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            createSvgGrid();
            generateProblem();
            updateStatsDisplay();
        });
    </script>
</body>
</html>
