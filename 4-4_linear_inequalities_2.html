<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphing Linear Inequalities</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use the Inter font family */
        body {
            font-family: 'Inter', sans-serif;
        }
        .correct-text {
            color: #166534; /* green-800 */
            font-weight: 600;
        }
        .incorrect-text {
            color: #991b1b; /* red-800 */
            font-weight: 600;
        }
        /* Style for the graph */
        .graph-container {
            width: 100%;
            max-width: 480px; /* 480/16 = 30px per grid */
            margin: 0 auto;
            position: relative;
            aspect-ratio: 1 / 1; /* Keep it square */
            border: 1px solid #ccc;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            cursor: crosshair;
        }
        .graph-container svg {
            display: block;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Keep shade inside */
        }
        .grid-line {
            stroke: #e5e7eb; /* Light gray */
            stroke-width: 1;
        }
        .axis-line {
            stroke: #4b5563; /* Darker gray */
            stroke-width: 2;
        }
        .axis-label {
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            fill: #4b5563;
        }
        /* Student-drawn elements */
        .student-point {
            fill: #2563eb; /* blue-600 */
            stroke: #ffffff;
            stroke-width: 2;
        }
        .student-line {
            stroke: #2563eb; /* blue-600 */
            stroke-width: 3;
        }
        .student-line-dashed {
            stroke-dasharray: 5 5;
        }
        .shade-region {
            fill: #2563eb; /* blue-600 */
            opacity: 0.3;
        }
        .correct-line {
            stroke: #16a34a; /* green-600 */
            stroke-width: 4;
        }
        .correct-line-dashed {
            stroke-dasharray: 6 6;
        }
        .correct-shade {
            fill: #16a34a; /* green-600 */
            opacity: 0.3;
        }
        /* Style for line style buttons */
        .style-btn {
            background-color: #f3f4f6; /* gray-100 */
            border: 2px solid #d1d5db; /* gray-300 */
            color: #374151; /* gray-700 */
        }
        .style-btn-active {
            background-color: #dbeafe; /* blue-100 */
            border: 2px solid #3b82f6; /* blue-500 */
            color: #1e40af; /* blue-800 */
            font-weight: 600;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 min-h-screen p-4 md:p-8 flex items-center justify-center">

    <div class="max-w-xl w-full">
        <header class="mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800 text-center">Graphing Linear Inequalities</h1>
            <p class="text-lg text-gray-600 text-center mt-2">Graph the inequality in 3 steps</p>
            <div id="game-stats" class="text-2xl font-bold text-center mt-4 text-gray-700 flex justify-center gap-6">
                <div id="lives-counter" class="text-red-500">Lives: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                <div id="score-counter" class="text-blue-600">Score: 0</div>
            </div>
        </header>

        <div class="bg-white p-6 md:p-8 rounded-lg shadow-xl">
            <div class="text-center">
                <p class="text-lg text-gray-600">Graph the following inequality:</p>
                <p id="equation-display" class="text-4xl font-bold text-blue-600 my-3" style="font-family: 'Times New Roman', Times, serif;">y &lt; 2x + 1</p>
                <p id="instruction-text" class="text-lg text-gray-700 font-semibold h-6">1. Click the y-intercept.</p>
            </div>

            <div class="my-4">
                <div class="graph-container" id="graph-container">
                    <svg id="svg-grid" viewBox="0 0 480 480"></svg>
                </div>
            </div>
            
            <div id="feedback-area" class="text-center h-12 mb-4">
                </div>

            <div id="style-picker" class="grid grid-cols-2 gap-4 mb-4 hidden">
                <button id="solid-btn" class="style-btn w-full px-6 py-3 rounded-lg font-semibold text-lg transition-colors shadow-sm">Solid Line (‚Äî)</button>
                <button id="dashed-btn" class="style-btn w-full px-6 py-3 rounded-lg font-semibold text-lg transition-colors shadow-sm">Dashed Line (---)</button>
            </div>

            <div class="grid grid-cols-2 gap-4">
                <button id="reset-btn" class="w-full bg-gray-500 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-gray-600 transition-colors shadow-md hidden col-span-2">
                    Reset Graph
                </button>
                <button id="check-btn" class="w-full bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-blue-700 transition-colors shadow-md hidden col-span-2">
                    Check Answer
                </button>
                <button id="next-btn" class="w-full bg-green-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-green-700 transition-colors shadow-md hidden col-span-2">
                    Next Question
                </button>
                <button id="restart-btn" class="w-full bg-red-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:bg-red-700 transition-colors shadow-md hidden col-span-2">
                    Restart Game
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const graphContainer = document.getElementById('graph-container');
        const svgGrid = document.getElementById('svg-grid');
        const equationDisplay = document.getElementById('equation-display');
        const instructionText = document.getElementById('instruction-text');
        const feedbackArea = document.getElementById('feedback-area');
        const checkBtn = document.getElementById('check-btn');
        const resetBtn = document.getElementById('reset-btn');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const stylePicker = document.getElementById('style-picker');
        const solidBtn = document.getElementById('solid-btn');
        const dashedBtn = document.getElementById('dashed-btn');
        const livesCounter = document.getElementById('lives-counter');
        const scoreCounter = document.getElementById('score-counter');

        // --- Game State ---
        let lives = 3;
        let score = 0;
        let isGameOver = false;
        let currentEquation = {};
        let clickedPoints = []; // Stores {x, y} cartesian coordinates
        let chosenLineStyle = null; // 'solid' or 'dashed'
        let clickedShadeSide = null; // 'above' or 'below' (UPDATED)
        let nextEquationType = 'slopeIntercept'; // 'slopeIntercept' or 'standardForm'

        // --- Graphing Constants ---
        const SVG_SIZE = 480;
        const GRID_RANGE = 8; // -8 to 8
        const NUM_GRIDS = GRID_RANGE * 2; // 16
        const GRID_SIZE = SVG_SIZE / NUM_GRIDS; // 30px
        const MID = SVG_SIZE / 2;

        // --- Helper: Get Random Integer ---
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // --- Helper: Update Stats Display ---
        function updateStatsDisplay() {
            livesCounter.innerHTML = `Lives: ${'‚ù§Ô∏è'.repeat(lives)}${'üñ§'.repeat(3 - lives)}`;
            scoreCounter.innerHTML = `Score: ${score}`;
        }

        // --- Coordinate Conversion ---
        function toPixelCoords(cx, cy) {
            return {
                x: MID + (cx * GRID_SIZE),
                y: MID - (cy * GRID_SIZE) // SVG y-axis is inverted
            };
        }

        function toCartesianCoords(px, py) {
            return {
                x: Math.round((px - MID) / GRID_SIZE),
                y: Math.round((MID - py) / GRID_SIZE) // SVG y-axis is inverted
            };
        }

        // --- SVG Drawing ---
        function createSvgGrid() {
            svgGrid.innerHTML = ''; // Clear previous grid

            // Draw grid lines
            for (let i = 0; i <= NUM_GRIDS; i++) {
                let pos = i * GRID_SIZE;
                // Horizontal
                let hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hLine.setAttribute('x1', 0); hLine.setAttribute('y1', pos);
                hLine.setAttribute('x2', SVG_SIZE); hLine.setAttribute('y2', pos);
                hLine.classList.add('grid-line');
                svgGrid.appendChild(hLine);
                // Vertical
                let vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                vLine.setAttribute('x1', pos); vLine.setAttribute('y1', 0);
                vLine.setAttribute('x2', pos); vLine.setAttribute('y2', SVG_SIZE);
                vLine.classList.add('grid-line');
                svgGrid.appendChild(vLine);
            }

            // Draw axes
            let xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', MID);
            xAxis.setAttribute('x2', SVG_SIZE); xAxis.setAttribute('y2', MID);
            xAxis.classList.add('axis-line');
            svgGrid.appendChild(xAxis);

            let yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', MID); yAxis.setAttribute('y1', 0);
            yAxis.setAttribute('x2', MID); yAxis.setAttribute('y2', SVG_SIZE);
            yAxis.classList.add('axis-line');
            svgGrid.appendChild(yAxis);

            // Add axis labels
            function addLabel(x, y, text, align = 'middle', baseline = 'central') {
                let label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', y);
                label.setAttribute('text-anchor', align);
                label.setAttribute('dominant-baseline', baseline);
                label.textContent = text;
                label.classList.add('axis-label');
                svgGrid.appendChild(label);
            }

            for(let i = 1; i <= GRID_RANGE; i++) {
                if (i % 2 === 0) { // Label every 2 units
                    addLabel(MID + (i * GRID_SIZE), MID + 12, i); // +x
                    addLabel(MID - (i * GRID_SIZE), MID + 12, -i); // -x
                    addLabel(MID - 12, MID - (i * GRID_SIZE), i, 'end'); // +y
                    addLabel(MID - 12, MID + (i * GRID_SIZE), -i, 'end'); // -y
                }
            }
        }

        function drawPoint(cx, cy, id) {
            const p = toPixelCoords(cx, cy);
            let circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('id', id);
            circle.setAttribute('cx', p.x);
            circle.setAttribute('cy', p.y);
            circle.setAttribute('r', 5);
            circle.classList.add('student-point');
            svgGrid.appendChild(circle);
        }

        function drawFullLine(m, b, id, lineClass) {
            const x1 = -GRID_RANGE;
            const y1 = m * x1 + b;
            const x2 = GRID_RANGE;
            const y2 = m * x2 + b;
            const px1 = toPixelCoords(x1, y1);
            const px2 = toPixelCoords(x2, y2);
            
            let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('id', id);
            line.setAttribute('x1', px1.x);
            line.setAttribute('y1', px1.y);
            line.setAttribute('x2', px2.x);
            line.setAttribute('y2', px2.y);
            
            const classes = lineClass.split(' '); 
            line.classList.add(...classes); 
            
            svgGrid.appendChild(line);
        }
        
        function drawShadeRegion(m, b, side, id, shadeClass) {
            // UPDATED: side is now 'above' or 'below'
            const shadeAbove = (side === 'above');

            // Get the 4 corner points of the polygon
            const p1 = toPixelCoords(-GRID_RANGE, m * -GRID_RANGE + b); // Line Left
            const p2 = toPixelCoords(GRID_RANGE, m * GRID_RANGE + b); // Line Right
            let c1, c2;

            if (shadeAbove) {
                c1 = toPixelCoords(-GRID_RANGE, GRID_RANGE); // Top-Left Corner
                c2 = toPixelCoords(GRID_RANGE, GRID_RANGE); // Top-Right Corner
            } else {
                c1 = toPixelCoords(-GRID_RANGE, -GRID_RANGE); // Bottom-Left Corner
                c2 = toPixelCoords(GRID_RANGE, -GRID_RANGE); // Bottom-Right Corner
            }
            
            let polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('id', id);
            polygon.setAttribute('points', `${p1.x},${p1.y} ${p2.x},${p2.y} ${c2.x},${c2.y} ${c1.x},${c1.y}`);
            polygon.classList.add(shadeClass);
            svgGrid.appendChild(polygon);
        }

        function clearStudentDrawings() {
            const p1 = document.getElementById('point-1');
            const p2 = document.getElementById('point-2');
            const line = document.getElementById('student-line');
            const shade = document.getElementById('student-shade');
            const answerLine = document.getElementById('answer-line');
            const answerShade = document.getElementById('answer-shade');

            if (p1) p1.remove();
            if (p2) p2.remove();
            if (line) line.remove();
            if (shade) shade.remove();
            if (answerLine) answerLine.remove();
            if (answerShade) answerShade.remove();
        }

        // --- Problem Generation ---
        function generateProblem() {
            if (isGameOver) return;

            let m, b;
            do {
                m = getRandomInt(-3, 3);
            } while (m === 0); // No horizontal/vertical lines
            
            b = getRandomInt(-5, 5);
            
            const inequalityTypes = ['<', '>', '‚â§', '‚â•'];
            const inequalitySymbol = inequalityTypes[getRandomInt(0, 3)];
            const isSolid = inequalitySymbol === '‚â§' || inequalitySymbol === '‚â•';

            let A, B, C;
            
            if (nextEquationType === 'slopeIntercept') {
                // y [op] mx + b  =>  mx - y [op] -b
                A = m;
                B = -1;
                C = -b;
                // Adjust operator for B=-1
                // y > mx + b => mx - y < -b
                // y < mx + b => mx - y > -b
                let opForCheck;
                if (inequalitySymbol === '>') opForCheck = '<';
                if (inequalitySymbol === '<') opForCheck = '>';
                if (inequalitySymbol === '‚â•') opForCheck = '‚â§';
                if (inequalitySymbol === '‚â§') opForCheck = '‚â•';
                
                let mStr = (m === 1) ? "x" : (m === -1) ? "-x" : `${m}x`;
                let bStr = (b > 0) ? `+ ${b}` : (b < 0) ? `- ${Math.abs(b)}` : "";
                equationDisplay.innerHTML = `y ${inequalitySymbol.replace('<=', '&le;').replace('>=', '&ge;')} ${mStr} ${bStr}`;
                
                currentEquation = { m, b, A, B, C, isSolid, inequalitySymbol: opForCheck };
                nextEquationType = 'standardForm';
            } else {
                // Generate Ax + By [op] C form
                // From y = mx + b => -mx + y = b
                if (m > 0) { // e.g., y = 2x + 3  =>  -2x + y = 3 => 2x - y = -3
                    A = m; B = -1; C = -b;
                } else { // e.g., y = -2x + 3 =>  2x + y = 3
                    A = -m; B = 1; C = b;
                }
                
                // FIX: Standard Form Test
                // When we plug points into Ax + By, we must test against the
                // displayed inequality symbol. We should NOT flip the symbol here
                // because the "flip" happens naturally in the math of (Ax + By).
                let opForCheck = inequalitySymbol;

                let A_str = (A === 1) ? "x" : `${A}x`;
                let B_str = (B === 1) ? "+ y" : (B === -1) ? "- y" : (B > 0) ? `+ ${B}y` : `- ${Math.abs(B)}y`;
                
                equationDisplay.innerHTML = `${A_str} ${B_str} ${inequalitySymbol.replace('<=', '&le;').replace('>=', '&ge;')} ${C}`;
                currentEquation = { m, b, A, B, C, isSolid, inequalitySymbol: opForCheck };
                nextEquationType = 'slopeIntercept';
            }

            // NEW: Determine if correct region is Above or Below by testing Y = 1000
            // We rely on A, B, C and opForCheck
            const val = A * 0 + B * 1000;
            const op = currentEquation.inequalitySymbol;
            const cVal = currentEquation.C;
            
            if (op === '<') currentEquation.shadeAbove = (val < cVal);
            else if (op === '>') currentEquation.shadeAbove = (val > cVal);
            else if (op === '‚â§') currentEquation.shadeAbove = (val <= cVal);
            else if (op === '‚â•') currentEquation.shadeAbove = (val >= cVal);

            resetState();
        }

        // --- Game Logic ---
        function handleGraphClick(event) {
            const rect = svgGrid.getBoundingClientRect();
            const px = event.clientX - rect.left;
            const py = event.clientY - rect.top;
            const p = toCartesianCoords(px, py);
            
            if (clickedPoints.length === 0) {
                // First click (y-intercept)
                clickedPoints.push(p);
                drawPoint(p.x, p.y, 'point-1');
                instructionText.textContent = '2. Click a second point for the boundary line.';
                resetBtn.classList.remove('hidden');
            } else if (clickedPoints.length === 1) {
                // Second click (slope point)
                if (p.x === clickedPoints[0].x && p.y === clickedPoints[0].y) return; // Ignore same point
                
                clickedPoints.push(p);
                drawPoint(p.x, p.y, 'point-2');
                instructionText.textContent = "3. Choose the line style.";
                stylePicker.classList.remove('hidden');
                graphContainer.style.pointerEvents = 'none'; // Disable graph clicks
            } else if (clickedPoints.length === 2 && chosenLineStyle) {
                // Third click (shading)
                // UPDATED: Calculate slope/intercept from STUDENT points
                const { m, b } = getLineFromPoints(clickedPoints[0], clickedPoints[1]);
                
                // Determine if click is above or below the student line
                const yOnLine = m * p.x + b;
                clickedShadeSide = (p.y > yOnLine) ? 'above' : 'below';
                
                // Draw the shade
                drawShadeRegion(m, b, clickedShadeSide, 'student-shade', 'shade-region');

                instructionText.textContent = "Check your work!";
                checkBtn.classList.remove('hidden');
                graphContainer.style.pointerEvents = 'none'; // Disable clicks
            }
        }

        function handleStyleClick(style) {
            chosenLineStyle = style;
            solidBtn.classList.toggle('style-btn-active', style === 'solid');
            dashedBtn.classList.toggle('style-btn-active', style === 'dashed');

            // Draw the student's line
            const existingLine = document.getElementById('student-line');
            if (existingLine) existingLine.remove();
            
            const { m, b } = getLineFromPoints(clickedPoints[0], clickedPoints[1]);
            let lineClass = 'student-line';
            if (style === 'dashed') lineClass += ' student-line-dashed';
            drawFullLine(m, b, 'student-line', lineClass);

            instructionText.textContent = "4. Click the correct region to shade.";
            graphContainer.style.pointerEvents = 'auto'; // Re-enable for shading
            stylePicker.classList.add('hidden');
        }

        function getLineFromPoints(p1, p2) {
            if (p1.x === p2.x) return { m: Infinity, b: undefined }; // Vertical
            const m = (p2.y - p1.y) / (p2.x - p1.x);
            const b = p1.y - m * p1.x;
            return { m, b };
        }

        function resetState() {
            clickedPoints = [];
            chosenLineStyle = null;
            clickedShadeSide = null;
            clearStudentDrawings();
            
            graphContainer.style.pointerEvents = 'auto'; // Re-enable clicks
            instructionText.textContent = '1. Click the y-intercept.';
            feedbackArea.innerHTML = '';
            
            checkBtn.classList.add('hidden');
            resetBtn.classList.add('hidden');
            nextBtn.classList.add('hidden');
            stylePicker.classList.add('hidden');
            solidBtn.classList.remove('style-btn-active');
            dashedBtn.classList.remove('style-btn-active');
        }

        function checkAnswer() {
            const p1 = clickedPoints[0];
            const p2 = clickedPoints[1];
            const { m, b, isSolid } = currentEquation;

            // Check 1: Is the y-intercept correct?
            const isInterceptCorrect = (p1.x === 0 && p1.y === b);
            
            // Check 2: Is the second point on the line?
            // Use a small tolerance for floating point
            const isSlopePointCorrect = Math.abs(p2.y - (m * p2.x + b)) < 0.001;
            
            // Check 3: Is the line style correct?
            const isStyleCorrect = (chosenLineStyle === (isSolid ? 'solid' : 'dashed'));

            // UPDATED: Check 4: Is the shading correct?
            const correctSide = currentEquation.shadeAbove ? 'above' : 'below';
            const isShadeCorrect = (clickedShadeSide === correctSide);

            checkBtn.classList.add('hidden');
            resetBtn.classList.add('hidden');

            if (isInterceptCorrect && isSlopePointCorrect && isStyleCorrect && isShadeCorrect) {
                // ALL CORRECT
                score++;
                updateStatsDisplay();
                feedbackArea.innerHTML = `<p class="correct-text">Correct! Great job!</p>`;
                
                // Draw correct answer
                clearStudentDrawings();
                let correctLineClass = isSolid ? 'correct-line' : 'correct-line correct-line-dashed';
                drawFullLine(m, b, 'answer-line', correctLineClass);
                
                drawShadeRegion(m, b, correctSide, 'answer-shade', 'correct-shade');
                
                nextBtn.classList.remove('hidden');
            } else {
                // INCORRECT
                lives--;
                updateStatsDisplay();
                let errorMsgs = [];
                if (!isInterceptCorrect) errorMsgs.push("Your y-intercept is not in the correct spot.");
                else if (!isSlopePointCorrect) errorMsgs.push("Your y-intercept is right, but your second point is off the line.");
                
                if (!isStyleCorrect) errorMsgs.push(`The line should be <strong>${isSolid ? 'solid' : 'dashed'}</strong>.`);
                if (!isShadeCorrect) errorMsgs.push("You shaded the wrong region.");
                
                if (lives <= 0) {
                    // GAME OVER
                    isGameOver = true;
                    feedbackArea.innerHTML = `<p class="incorrect-text text-xl font-bold">Game Over! Final Score: ${score}</p>`;
                    // Show the correct answer
                    clearStudentDrawings();
                    let correctLineClass = isSolid ? 'correct-line' : 'correct-line correct-line-dashed'; 
                    drawFullLine(m, b, 'answer-line', correctLineClass);
                    
                    drawShadeRegion(m, b, correctSide, 'answer-shade', 'correct-shade');
                    restartBtn.classList.remove('hidden');
                } else {
                    // Try again
                    feedbackArea.innerHTML = `<p class="incorrect-text">${errorMsgs.join(' ')} Try again!</p>`;
                    resetBtn.classList.remove('hidden');
                    resetBtn.classList.add('col-span-2'); // Make reset button full width
                }
            }
        }

        function handleRestart() {
            lives = 3;
            score = 0;
            isGameOver = false;
            updateStatsDisplay();
            restartBtn.classList.add('hidden');
            generateProblem();
        }

        // --- Event Listeners ---
        svgGrid.addEventListener('click', handleGraphClick);
        solidBtn.addEventListener('click', () => handleStyleClick('solid'));
        dashedBtn.addEventListener('click', () => handleStyleClick('dashed'));
        checkBtn.addEventListener('click', checkAnswer);
        resetBtn.addEventListener('click', () => {
             resetState();
             instructionText.textContent = '1. Click the y-intercept.';
        });
        nextBtn.addEventListener('click', generateProblem);
        restartBtn.addEventListener('click', handleRestart);

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            createSvgGrid();
            generateProblem();
            updateStatsDisplay();
        });
    </script>
</body>
</html>